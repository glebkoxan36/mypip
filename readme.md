Node Manager - –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö –Ω–æ–¥

üåü –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏

üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞

‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

üí° –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

ü§ñ –ü—Ä–∏–º–µ—Ä—ã

üîß API Reference

‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç

üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

üõ†Ô∏è –û—Ç–ª–∞–¥–∫–∞

üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

ü§ù –í–∫–ª–∞–¥ –≤ –ø—Ä–æ–µ–∫—Ç

üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è

üåü –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏
‚úÖ –ü–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ Nownodes
–ï–¥–∏–Ω—ã–π API –∫–ª—é—á –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç

–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Blockbook –∏ RPC API

WebSocket –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

‚úÖ –ú—É–ª—å—Ç–∏-–º–æ–Ω–µ—Ç–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞
Litecoin (LTC) - –ø–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞

Dogecoin (DOGE) - –ø–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞

Bitcoin (BTC) - –ø–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞

–õ–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –ª—é–±—É—é –¥—Ä—É–≥—É—é –º–æ–Ω–µ—Ç—É

‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π

–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –º–∞—Å—Ç–µ—Ä-–∞–¥—Ä–µ—Å

–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–æ–≤

–û—Ç–ø–∏—Å–∫–∞ –æ—Ç –∞–¥—Ä–µ—Å–æ–≤ –ø–æ—Å–ª–µ —Å–±–æ—Ä–∞

‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏

–í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –∞–¥—Ä–µ—Å–æ–≤

–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è

‚úÖ –ü—Ä–æ—Å—Ç–æ—Ç–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ YAML/JSON

–ì–æ—Ç–æ–≤—ã–µ –ø—Ä–∏–º–µ—Ä—ã –±–æ—Ç–æ–≤

–ü–æ–¥—Ä–æ–±–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç
–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞ 30 —Å–µ–∫—É–Ω–¥:
bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –º–æ–¥—É–ª—å
pip install git+https://github.com/yourusername/node-manager.git

# –°–æ–∑–¥–∞–π—Ç–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
python -c "from node_manager.nodeconfig import NodeConfig; NodeConfig.generate_config_template()"

# –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª .env –∏ node_config.yaml
–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–±–æ—á–∏–π –±–æ—Ç:
python
import asyncio
from node_manager import NodeManager

async def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –µ–¥–∏–Ω—ã–º API –∫–ª—é—á–æ–º
    manager = NodeManager()
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–¥—ã Litecoin
    ltc_node = await manager.get_node("LTC")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞
    balance = await ltc_node.get_balance("ltc1q...")
    print(f"–ë–∞–ª–∞–Ω—Å: {balance['total']} LTC")
    
    # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–¥—Ä–µ—Å–∞
    await manager.monitor_address("LTC", "ltc1q...")
    
    # –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–±–æ—Ä–∞
    await manager.start_auto_collection()

asyncio.run(main())
üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞
–°–ø–æ—Å–æ–± 1: –ò–∑ GitHub (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
bash
# –ü–æ—Å–ª–µ–¥–Ω—è—è –≤–µ—Ä—Å–∏—è –∏–∑ main –≤–µ—Ç–∫–∏
pip install git+https://github.com/yourusername/node-manager.git

# –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è
pip install git+https://github.com/yourusername/node-manager.git@v2.0.0

# –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –≤–µ—Ç–∫–∞
pip install git+https://github.com/yourusername/node-manager.git@develop
–°–ø–æ—Å–æ–± 2: –õ–æ–∫–∞–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞
bash
# –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
git clone https://github.com/yourusername/node-manager.git
cd node-manager

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ —Ä–µ–∂–∏–º–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
pip install -e .

# –ò–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–∞–∫ –ø–∞–∫–µ—Ç
python setup.py install
–°–ø–æ—Å–æ–± 3: –ò–∑ PyPI (–ø–æ—Å–ª–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏)
bash
pip install node-manager
–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
–ú–æ–¥—É–ª—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç:

aiohttp>=3.8.0 - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ HTTP –∑–∞–ø—Ä–æ—Å—ã

websockets>=11.0.0 - WebSocket –∫–ª–∏–µ–Ω—Ç

PyYAML>=6.0 - –†–∞–±–æ—Ç–∞ —Å YAML –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π

python-dotenv>=1.0.0 - –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è

bip-utils>=2.7.0 - –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–æ–≤

‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
–®–∞–≥ 1: –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è
bash
# –°–æ–∑–¥–∞–π—Ç–µ .env —Ñ–∞–π–ª –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞
cat > .env << EOL
# –ï–¥–∏–Ω—ã–π API –∫–ª—é—á Nownodes –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç
NOWNODES_API_KEY=–≤–∞—à_api_–∫–ª—é—á_–æ—Ç_nownodes

# –ú–∞—Å—Ç–µ—Ä-–∞–¥—Ä–µ—Å–∞ –¥–ª—è —Å–±–æ—Ä–∞ —Å—Ä–µ–¥—Å—Ç–≤
LTC_MASTER_ADDRESS=ltc1q–≤–∞—à_–º–∞—Å—Ç–µ—Ä_–∞–¥—Ä–µ—Å
DOGE_MASTER_ADDRESS=D–≤–∞—à_–º–∞—Å—Ç–µ—Ä_–∞–¥—Ä–µ—Å
BTC_MASTER_ADDRESS=bc1q–≤–∞—à_–º–∞—Å—Ç–µ—Ä_–∞–¥—Ä–µ—Å

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
LOG_LEVEL=INFO
DB_PATH=node_data.db
EOL
–®–∞–≥ 2: –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
python
# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —à–∞–±–ª–æ–Ω–∞
python -c "from node_manager.nodeconfig import NodeConfig; NodeConfig.generate_config_template('node_config.yaml')"
–ò–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ node_config.yaml –≤—Ä—É—á–Ω—É—é:

yaml
# node_config.yaml
nownodes:
  api_key: "${NOWNODES_API_KEY}"  # –ï–¥–∏–Ω—ã–π –∫–ª—é—á –∏–∑ .env —Ñ–∞–π–ª–∞
  timeout: 30
  max_retries: 3

coins:
  LTC:
    enabled: true
    blockbook_url: "https://ltcbook.nownodes.io"
    rpc_url: "https://ltc.nownodes.io"
    network: "mainnet"
    master_address: "${LTC_MASTER_ADDRESS}"
    min_collection_amount: 0.001
    collection_fee: 0.0001
    required_confirmations: 3
    
  DOGE:
    enabled: true
    blockbook_url: "https://dogebook.nownodes.io"
    rpc_url: "https://doge.nownodes.io"
    network: "mainnet"
    master_address: "${DOGE_MASTER_ADDRESS}"
    min_collection_amount: 10.0
    collection_fee: 1.0
    required_confirmations: 6

services:
  monitoring:
    enabled: true
    check_interval: 1800  # 30 –º–∏–Ω—É—Ç
    
  collection:
    enabled: true
    auto_start: true
–®–∞–≥ 3: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
python
from node_manager.nodeconfig import NodeConfig

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ API –∫–ª—é—á–∞ –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç
NodeConfig.update_api_key("–Ω–æ–≤—ã–π_–∫–ª—é—á")

# –í–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –º–æ–Ω–µ—Ç
NodeConfig.enable_coin("BTC", True)  # –í–∫–ª—é—á–∏—Ç—å Bitcoin

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–∞—Å—Ç–µ—Ä-–∞–¥—Ä–µ—Å–∞
NodeConfig.set_master_address("LTC", "ltc1q–Ω–æ–≤—ã–π_–∞–¥—Ä–µ—Å")

# –ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å–±–æ—Ä–∞
NodeConfig.set_collection_params(
    coin_type="LTC",
    min_amount=0.002,     # –ù–æ–≤—ã–π –º–∏–Ω–∏–º—É–º
    fee=0.0002,           # –ù–æ–≤–∞—è –∫–æ–º–∏—Å—Å–∏—è
    confirmations=6       # –¢—Ä–µ–±—É–µ–º—ã–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
)

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = NodeConfig.load_config()
print(f"–í–∫–ª—é—á–µ–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç—ã: {NodeConfig.get_enabled_coins(config)}")
üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è:
text
node_manager/
‚îú‚îÄ‚îÄ __init__.py              # –û—Å–Ω–æ–≤–Ω–æ–π —ç–∫—Å–ø–æ—Ä—Ç
‚îú‚îÄ‚îÄ nodeconfig.py           # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
‚îú‚îÄ‚îÄ core/                   # –Ø–¥—Ä–æ –º–æ–¥—É–ª—è
‚îÇ   ‚îú‚îÄ‚îÄ base_node.py       # –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –Ω–æ–¥—ã
‚îÇ   ‚îú‚îÄ‚îÄ node_factory.py    # –§–∞–±—Ä–∏–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–¥
‚îÇ   ‚îú‚îÄ‚îÄ litecoin.py       # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Litecoin
‚îÇ   ‚îú‚îÄ‚îÄ dogecoin.py       # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Dogecoin
‚îÇ   ‚îî‚îÄ‚îÄ bitcoin.py        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Bitcoin
‚îú‚îÄ‚îÄ api/                    # –ö–ª–∏–µ–Ω—Ç—ã API
‚îÇ   ‚îú‚îÄ‚îÄ rpc.py            # RPC –∫–ª–∏–µ–Ω—Ç
‚îÇ   ‚îú‚îÄ‚îÄ blockbook.py      # Blockbook API –∫–ª–∏–µ–Ω—Ç
‚îÇ   ‚îî‚îÄ‚îÄ websocket.py      # WebSocket –∫–ª–∏–µ–Ω—Ç
‚îú‚îÄ‚îÄ services/              # –°–µ—Ä–≤–∏—Å—ã
‚îÇ   ‚îú‚îÄ‚îÄ monitor.py        # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
‚îÇ   ‚îú‚îÄ‚îÄ collector.py      # –°–±–æ—Ä —Å—Ä–µ–¥—Å—Ç–≤
‚îÇ   ‚îî‚îÄ‚îÄ manager.py        # –û—Å–Ω–æ–≤–Ω–æ–π –º–µ–Ω–µ–¥–∂–µ—Ä
‚îî‚îÄ‚îÄ utils/                 # –£—Ç–∏–ª–∏—Ç—ã
    ‚îú‚îÄ‚îÄ config.py         # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥–æ–≤
    ‚îú‚îÄ‚îÄ exceptions.py     # –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
    ‚îî‚îÄ‚îÄ validators.py     # –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–æ–≤
–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     –í–∞—à –±–æ—Ç     ‚îÇ    ‚îÇ   NodeManager   ‚îÇ    ‚îÇ   NodeConfig    ‚îÇ
‚îÇ                 ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ
‚îÇ  - –ö–æ–º–∞–Ω–¥—ã      ‚îÇ    ‚îÇ  - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ   ‚îÇ    ‚îÇ  - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ‚îÇ
‚îÇ  - –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ ‚îÇ    ‚îÇ  - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è  ‚îÇ    ‚îÇ  - –ù–∞—Å—Ç—Ä–æ–π–∫–∏    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   BaseNode      ‚îÇ    ‚îÇ   –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥    ‚îÇ    ‚îÇ    –°–±–æ—Ä—â–∏–∫      ‚îÇ
‚îÇ                 ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ
‚îÇ  - –ë–∞–ª–∞–Ω—Å—ã      ‚îÇ    ‚îÇ  - WebSocket    ‚îÇ    ‚îÇ  - UTXO —Å–±–æ—Ä    ‚îÇ
‚îÇ  - –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏   ‚îÇ    ‚îÇ  - –û–ø–æ–≤–µ—â–µ–Ω–∏—è   ‚îÇ    ‚îÇ  - –ü–æ–¥–ø–∏—Å—å      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Nownodes     ‚îÇ    ‚îÇ   Blockbook     ‚îÇ
‚îÇ      RPC        ‚îÇ    ‚îÇ      API        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üí° –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
–ë–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:
python
import asyncio
from node_manager import NodeManager

async def basic_operations():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    manager = NodeManager(config_path="node_config.yaml")
    
    # 1. –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–¥—ã
    ltc_node = await manager.get_node("LTC")
    
    # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞
    balance = await ltc_node.get_balance("ltc1q...")
    print(f"–ë–∞–ª–∞–Ω—Å: {balance['total']} LTC")
    
    # 3. –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–¥—Ä–µ—Å–µ
    info = await ltc_node.get_address_info("ltc1q...")
    print(f"–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: {info['transaction_count']}")
    
    # 4. –ü–æ–ª—É—á–µ–Ω–∏–µ UTXO
    utxos = await ltc_node.get_address_utxos("ltc1q...")
    print(f"–ù–∞–π–¥–µ–Ω–æ UTXO: {len(utxos)}")
    
    # 5. –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞
    validation = await ltc_node.validate_address("ltc1q...")
    print(f"–ê–¥—Ä–µ—Å –≤–∞–ª–∏–¥–µ–Ω: {validation['is_valid']}")
    
    # 6. –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–ª–æ–∫—á–µ–π–Ω–µ
    blockchain = await ltc_node.get_blockchain_info()
    print(f"–í—ã—Å–æ—Ç–∞ –±–ª–æ–∫–∞: {blockchain['blocks']}")

asyncio.run(basic_operations())
–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:
python
async def transaction_operations():
    manager = NodeManager()
    node = await manager.get_node("LTC")
    
    # 1. –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    tx_info = await node.get_transaction("txid_–ø—Ä–∏–º–µ—Ä")
    print(f"–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: {tx_info['amount']} LTC")
    
    # 2. –°–æ–∑–¥–∞–Ω–∏–µ —Å—ã—Ä–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    inputs = [
        {
            "txid": "–ø—Ä–µ–¥—ã–¥—É—â–∏–π_txid",
            "vout": 0,
            "address": "–∏—Å—Ö–æ–¥–Ω—ã–π_–∞–¥—Ä–µ—Å"
        }
    ]
    
    outputs = {
        "ltc1q–ø–æ–ª—É—á–∞—Ç–µ–ª—å": 0.001  # 0.001 LTC
    }
    
    raw_tx = await node.create_raw_transaction(inputs, outputs)
    print(f"–°–æ–∑–¥–∞–Ω–∞ —Å—ã—Ä–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: {raw_tx[:50]}...")
    
    # 3. –ü–æ–¥–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    private_keys = ["–≤–∞—à_–ø—Ä–∏–≤–∞—Ç–Ω—ã–π_–∫–ª—é—á"]
    signed_tx = await node.sign_raw_transaction(raw_tx, private_keys)
    
    if signed_tx['complete']:
        # 4. –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        txid = await node.send_transaction(signed_tx['hex'])
        print(f"–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: {txid}")
ü§ñ –ü—Ä–∏–º–µ—Ä—ã
–ü—Ä–∏–º–µ—Ä 1: –ü—Ä–æ—Å—Ç–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–¥—Ä–µ—Å–æ–≤
python
"""
simple_monitor.py - –ü—Ä–æ—Å—Ç–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–¥—Ä–µ—Å–æ–≤ Litecoin
"""

import asyncio
import logging
from node_manager import NodeManager

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def handle_transaction(coin, data):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–æ–≤—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π"""
    address = data.get('address')
    tx = data.get('transaction', {})
    
    if address and tx:
        logger.info(f"üí∞ –ù–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –¥–ª—è {coin}:{address}")
        logger.info(f"   TXID: {tx.get('txid')}")
        logger.info(f"   –°—É–º–º–∞: {tx.get('amount', 0)}")
        logger.info(f"   –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {tx.get('confirmations', 0)}")

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞...")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    manager = NodeManager()
    
    try:
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–¥—ã Litecoin
        ltc_node = await manager.get_node("LTC")
        logger.info(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ {ltc_node.coin_name}")
        
        # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–º
        await manager.start_monitoring("LTC", handle_transaction)
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        addresses = [
            "ltc1q489hgnahvr9zspytmsu6vew8nc4j6c3aqkdvxg",
            "ltc1qexample1addressfortesting",
            "ltc1qexample2addressfortesting"
        ]
        
        for address in addresses:
            # –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞ –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º
            validation = await ltc_node.validate_address(address)
            if validation['is_valid']:
                await manager.monitor_address("LTC", address)
                logger.info(f"üëÅÔ∏è  –ú–æ–Ω–∏—Ç–æ—Ä–∏–º –∞–¥—Ä–µ—Å: {address}")
            else:
                logger.warning(f"‚ö†Ô∏è  –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π –∞–¥—Ä–µ—Å: {address}")
        
        logger.info("üì° –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω. –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏.")
        
        # –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
        while True:
            await asyncio.sleep(1)
            
    except KeyboardInterrupt:
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
    finally:
        # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        await manager.stop()

if __name__ == "__main__":
    asyncio.run(main())
–ü—Ä–∏–º–µ—Ä 2: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä—â–∏–∫ —Å—Ä–µ–¥—Å—Ç–≤
python
"""
auto_collector.py - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä —Å—Ä–µ–¥—Å—Ç–≤ —Å –∞–¥—Ä–µ—Å–æ–≤
"""

import asyncio
import logging
from datetime import datetime
from node_manager import NodeManager
from node_manager.nodeconfig import NodeConfig

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AutoCollector:
    def __init__(self):
        self.manager = None
        self.collectors = {}
        self.addresses_db = {}
        
    async def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–±–æ—Ä—â–∏–∫–∞"""
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–±–æ—Ä—â–∏–∫–∞...")
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        config = NodeConfig.load_config()
        enabled_coins = NodeConfig.get_enabled_coins(config)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        self.manager = NodeManager(config=config)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–±–æ—Ä—â–∏–∫–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–Ω–µ—Ç—ã
        for coin in enabled_coins:
            coin_config = NodeConfig.get_coin_config(coin, config)
            collector = await self.manager.create_collector(
                coin,
                master_address=coin_config.get('master_address'),
                fee=coin_config.get('collection_fee', 0.0001)
            )
            self.collectors[coin] = collector
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∞–¥—Ä–µ—Å–æ–≤ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –±–æ—Ç–µ - –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö)
        await self.load_addresses()
        
        # –ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ —Å–±–æ—Ä–∞
        asyncio.create_task(self.collection_worker())
        
        # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        await self.manager.start_monitoring_for_all(self.handle_transaction)
        
        logger.info("‚úÖ –°–±–æ—Ä—â–∏–∫ –∑–∞–ø—É—â–µ–Ω")
        
        # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
        while True:
            await asyncio.sleep(1)
    
    async def load_addresses(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        # –ü—Ä–∏–º–µ—Ä –∞–¥—Ä–µ—Å–æ–≤ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –±–æ—Ç–µ –∑–∞–≥—Ä—É–∂–∞–π—Ç–µ –∏–∑ –ë–î)
        self.addresses_db = {
            "ltc1qaddress1": {
                "coin": "LTC",
                "private_key": "–≤–∞—à_–ø—Ä–∏–≤–∞—Ç–Ω—ã–π_–∫–ª—é—á_1",  # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ!
                "added": datetime.now(),
                "collected": False
            },
            "ltc1qaddress2": {
                "coin": "LTC",
                "private_key": "–≤–∞—à_–ø—Ä–∏–≤–∞—Ç–Ω—ã–π_–∫–ª—é—á_2",
                "added": datetime.now(),
                "collected": False
            }
        }
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–æ–≤ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
        for address, data in self.addresses_db.items():
            if not data['collected']:
                await self.manager.monitor_address(data['coin'], address)
                logger.info(f"üëÅÔ∏è  –î–æ–±–∞–≤–ª–µ–Ω –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {address}")
    
    async def collection_worker(self):
        """–§–æ–Ω–æ–≤—ã–π –≤–æ—Ä–∫–µ—Ä –¥–ª—è —Å–±–æ—Ä–∞"""
        check_interval = 1800  # 30 –º–∏–Ω—É—Ç
        
        while True:
            try:
                logger.info("üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è —Å–±–æ—Ä–∞...")
                
                for address, data in self.addresses_db.items():
                    if not data['collected']:
                        coin = data['coin']
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞
                        collector = self.collectors[coin]
                        estimation = await collector.estimate_collection(address)
                        
                        if estimation.get('can_collect'):
                            logger.info(f"üí∞ –ê–¥—Ä–µ—Å –≥–æ—Ç–æ–≤ –∫ —Å–±–æ—Ä—É: {address}")
                            
                            # –°–æ–±–∏—Ä–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞
                            result = await collector.collect_from_address(
                                address, 
                                data['private_key']
                            )
                            
                            if result and result.get('success'):
                                logger.info(f"‚úÖ –°—Ä–µ–¥—Å—Ç–≤–∞ —Å–æ–±—Ä–∞–Ω—ã: {result.get('amount')} {coin}")
                                data['collected'] = True
                                data['collected_at'] = datetime.now()
                                data['txid'] = result.get('txid')
                                
                                # –û—Ç–ø–∏—Å—ã–≤–∞–µ–º—Å—è –æ—Ç –∞–¥—Ä–µ—Å–∞
                                await self.manager.unmonitor_address(coin, address)
                            
                            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–±–æ—Ä–∞–º–∏
                            await asyncio.sleep(10)
                
                logger.info(f"‚è±Ô∏è  –°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ {check_interval/60} –º–∏–Ω—É—Ç")
                await asyncio.sleep(check_interval)
                
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ collection_worker: {e}")
                await asyncio.sleep(60)
    
    async def handle_transaction(self, coin, data):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π"""
        address = data.get('address')
        transaction = data.get('transaction', {})
        
        if address and transaction:
            confirmations = transaction.get('confirmations', 0)
            
            # –ï—Å–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞
            if confirmations >= 3:
                logger.info(f"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –¥–ª—è {address}")
                
                # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞
                if address in self.addresses_db and not self.addresses_db[address]['collected']:
                    collector = self.collectors[coin]
                    estimation = await collector.estimate_collection(address)
                    
                    if estimation.get('can_collect'):
                        await collector.collect_from_address(
                            address, 
                            self.addresses_db[address]['private_key']
                        )
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–±–æ—Ä—â–∏–∫–∞"""
        if self.manager:
            await self.manager.stop()
        logger.info("üõë –°–±–æ—Ä—â–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

async def main():
    collector = AutoCollector()
    
    try:
        await collector.start()
    except KeyboardInterrupt:
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        await collector.stop()

if __name__ == "__main__":
    asyncio.run(main())
–ü—Ä–∏–º–µ—Ä 3: –ú—É–ª—å—Ç–∏-–º–æ–Ω–µ—Ç–Ω—ã–π –±–æ—Ç —Å Telegram –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
python
"""
telegram_bot.py - –ë–æ—Ç —Å Telegram –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–æ–¥–∞–º–∏
"""

import asyncio
import logging
from typing import Dict, Any
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.middlewares.logging import LoggingMiddleware
from node_manager import NodeManager
from node_manager.nodeconfig import NodeConfig

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
API_TOKEN = "–í–ê–®_TELEGRAM_BOT_TOKEN"
ADMIN_IDS = [123456789]  # ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)
dp.middleware.setup(LoggingMiddleware())

# Node Manager
node_manager = None

@dp.message_handler(commands=['start'])
async def cmd_start(message: types.Message):
    """–ö–æ–º–∞–Ω–¥–∞ /start"""
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω")
        return
    
    await message.answer(
        "ü§ñ Node Manager Bot\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/status - –°—Ç–∞—Ç—É—Å –Ω–æ–¥\n"
        "/balance <–∞–¥—Ä–µ—Å> - –ë–∞–ª–∞–Ω—Å –∞–¥—Ä–µ—Å–∞\n"
        "/monitor <–º–æ–Ω–µ—Ç–∞> <–∞–¥—Ä–µ—Å> - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–¥—Ä–µ—Å–∞\n"
        "/collect <–∞–¥—Ä–µ—Å> - –°–æ–±—Ä–∞—Ç—å —Å—Ä–µ–¥—Å—Ç–≤–∞\n"
        "/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "/coins - –°–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç\n"
        "/stop - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"
    )

@dp.message_handler(commands=['status'])
async def cmd_status(message: types.Message):
    """–°—Ç–∞—Ç—É—Å –Ω–æ–¥"""
    if not node_manager:
        await message.answer("‚ùå Node Manager –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        return
    
    try:
        status_text = "üìä –°—Ç–∞—Ç—É—Å –Ω–æ–¥:\n\n"
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        config = NodeConfig.load_config()
        enabled_coins = NodeConfig.get_enabled_coins(config)
        
        for coin in enabled_coins:
            try:
                node = await node_manager.get_node(coin)
                info = await node.get_blockchain_info()
                
                if 'error' not in info:
                    status_text += f"‚úÖ {coin}:\n"
                    status_text += f"   –ë–ª–æ–∫–æ–≤: {info.get('blocks', 0)}\n"
                    status_text += f"   –°–µ—Ç—å: {info.get('chain', 'unknown')}\n"
                else:
                    status_text += f"‚ùå {coin}: –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n"
                    
            except Exception as e:
                status_text += f"‚ùå {coin}: {str(e)[:50]}\n"
        
        await message.answer(status_text)
        
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

@dp.message_handler(commands=['balance'])
async def cmd_balance(message: types.Message):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –∞–¥—Ä–µ—Å–∞"""
    args = message.get_args().split()
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /balance <–º–æ–Ω–µ—Ç–∞> <–∞–¥—Ä–µ—Å>")
        return
    
    coin, address = args[0].upper(), args[1]
    
    try:
        node = await node_manager.get_node(coin)
        balance = await node.get_balance(address)
        
        if 'error' in balance:
            await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {balance['error']}")
        else:
            response = (
                f"üí∞ –ë–∞–ª–∞–Ω—Å {coin}:\n"
                f"–ê–¥—Ä–µ—Å: {address}\n"
                f"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {balance.get('confirmed', 0):.8f}\n"
                f"–ù–µ–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {balance.get('unconfirmed', 0):.8f}\n"
                f"–í—Å–µ–≥–æ: {balance.get('total', 0):.8f}"
            )
            await message.answer(response)
            
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

@dp.message_handler(commands=['monitor'])
async def cmd_monitor(message: types.Message):
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"""
    args = message.get_args().split()
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /monitor <–º–æ–Ω–µ—Ç–∞> <–∞–¥—Ä–µ—Å>")
        return
    
    coin, address = args[0].upper(), args[1]
    
    try:
        node = await node_manager.get_node(coin)
        validation = await node.validate_address(address)
        
        if not validation['is_valid']:
            await message.answer(f"‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π –∞–¥—Ä–µ—Å {coin}")
            return
        
        await node_manager.monitor_address(coin, address)
        await message.answer(f"‚úÖ –ê–¥—Ä–µ—Å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {coin}:{address}")
        
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

@dp.message_handler(commands=['stats'])
async def cmd_stats(message: types.Message):
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"""
    try:
        stats = await node_manager.get_stats()
        
        response = "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n"
        response += f"–ù–æ–¥ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ: {stats.get('nodes_connected', 0)}\n"
        response += f"–ú–æ–Ω–∏—Ç–æ—Ä–æ–≤ –∞–∫—Ç–∏–≤–Ω–æ: {stats.get('monitors_running', 0)}\n"
        response += f"–ê–¥—Ä–µ—Å–æ–≤ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ: {stats.get('addresses_monitored', 0)}\n"
        response += f"–°–±–æ—Ä–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats.get('collections_completed', 0)}\n"
        
        await message.answer(response)
        
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

@dp.message_handler(commands=['coins'])
async def cmd_coins(message: types.Message):
    """–°–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –º–æ–Ω–µ—Ç"""
    config = NodeConfig.load_config()
    enabled_coins = NodeConfig.get_enabled_coins(config)
    
    response = "ü™ô –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –º–æ–Ω–µ—Ç—ã:\n\n"
    for coin in enabled_coins:
        coin_config = NodeConfig.get_coin_config(coin, config)
        response += f"‚Ä¢ {coin} ({coin_config.get('coin_name')})\n"
        response += f"  –°–µ—Ç—å: {coin_config.get('network')}\n"
        response += f"  –ú–∞—Å—Ç–µ—Ä: {coin_config.get('master_address', '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω')[:20]}...\n"
    
    await message.answer(response)

async def on_startup(dp):
    """–ó–∞–ø—É—Å–∫ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –±–æ—Ç–∞"""
    global node_manager
    
    logging.info("üöÄ –ó–∞–ø—É—Å–∫ Node Manager Bot...")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Node Manager
    node_manager = NodeManager()
    
    # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    await node_manager.start_monitoring_for_all(
        lambda coin, data: handle_node_event(coin, data)
    )
    
    logging.info("‚úÖ Node Manager Bot –∑–∞–ø—É—â–µ–Ω")

async def on_shutdown(dp):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –≤—ã–∫–ª—é—á–µ–Ω–∏–∏"""
    global node_manager
    
    logging.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ Node Manager Bot...")
    
    if node_manager:
        await node_manager.stop()
    
    logging.info("‚úÖ Node Manager Bot –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

async def handle_node_event(coin: str, data: Dict[str, Any]):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π –æ—Ç –Ω–æ–¥"""
    event_type = data.get('type')
    
    if event_type == 'transaction':
        address = data.get('address')
        tx = data.get('transaction', {})
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º
        for admin_id in ADMIN_IDS:
            try:
                await bot.send_message(
                    admin_id,
                    f"üí∞ –ù–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è {coin}:\n"
                    f"–ê–¥—Ä–µ—Å: {address}\n"
                    f"TXID: {tx.get('txid')}\n"
                    f"–°—É–º–º–∞: {tx.get('amount', 0):.8f}"
                )
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    await dp.start_polling()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # –ó–∞–ø—É—Å–∫ —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏ —Å–æ–±—ã—Ç–∏–π
    from aiogram import executor
    executor.start_polling(
        dp, 
        skip_updates=True,
        on_startup=on_startup,
        on_shutdown=on_shutdown
    )
üîß API Reference
NodeManager
–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ–º–∏ –Ω–æ–¥–∞–º–∏.

python
from node_manager import NodeManager

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
manager = NodeManager(
    config_path="node_config.yaml",  # –ü—É—Ç—å –∫ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    api_key="–≤–∞—à_–∫–ª—é—á"               # API –∫–ª—é—á (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–æ–Ω—Ñ–∏–≥–µ)
)

# –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã
await manager.get_node("LTC")                    # –ü–æ–ª—É—á–∏—Ç—å –Ω–æ–¥—É
await manager.start_monitoring("LTC", callback)  # –ó–∞–ø—É—Å—Ç–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
await manager.monitor_address("LTC", "–∞–¥—Ä–µ—Å")   # –î–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
await manager.create_collector("LTC", ...)      # –°–æ–∑–¥–∞—Ç—å —Å–±–æ—Ä—â–∏–∫
await manager.start_auto_collection()           # –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ—Å–±–æ—Ä
await manager.stop()                            # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
await manager.get_stats()                       # –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
BaseNode
–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö –Ω–æ–¥.

python
# –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–¥—ã —á–µ—Ä–µ–∑ –º–µ–Ω–µ–¥–∂–µ—Ä
node = await manager.get_node("LTC")

# –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã
await node.connect()                          # –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –Ω–æ–¥–µ
await node.disconnect()                       # –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è
await node.get_balance("–∞–¥—Ä–µ—Å")              # –ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å
await node.get_address_info("–∞–¥—Ä–µ—Å")         # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–¥—Ä–µ—Å–µ
await node.get_transaction("txid")           # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
await node.get_address_utxos("–∞–¥—Ä–µ—Å")        # –ü–æ–ª—É—á–∏—Ç—å UTXO
await node.send_transaction("—Å—ã—Ä–∞—è_—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è")  # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
await node.validate_address("–∞–¥—Ä–µ—Å")         # –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞
await node.get_blockchain_info()             # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–ª–æ–∫—á–µ–π–Ω–µ
await node.estimate_fee(blocks=3)            # –û—Ü–µ–Ω–∏—Ç—å –∫–æ–º–∏—Å—Å–∏—é
await node.create_raw_transaction(inputs, outputs)  # –°–æ–∑–¥–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
await node.sign_raw_transaction(raw_tx, private_keys)  # –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
await node.get_transaction_history("–∞–¥—Ä–µ—Å", limit=10)  # –ò—Å—Ç–æ—Ä–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
await node.batch_get_balances(["–∞–¥—Ä–µ—Å1", "–∞–¥—Ä–µ—Å2"])  # –ü–∞–∫–µ—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å –±–∞–ª–∞–Ω—Å–æ–≤
TransactionMonitor
–°–µ—Ä–≤–∏—Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —á–µ—Ä–µ–∑ WebSocket.

python
from node_manager.services.monitor import TransactionMonitor

monitor = TransactionMonitor(
    node=node,                               # –≠–∫–∑–µ–º–ø–ª—è—Ä –Ω–æ–¥—ã
    on_transaction=callback_function,        # –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
    config=monitor_config                    # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
)

await monitor.start()                        # –ó–∞–ø—É—Å—Ç–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
await monitor.subscribe_address("–∞–¥—Ä–µ—Å")    # –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∞–¥—Ä–µ—Å
await monitor.unsubscribe_address("–∞–¥—Ä–µ—Å")  # –û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç –∞–¥—Ä–µ—Å–∞
await monitor.stop()                         # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
is_running = monitor.is_running()            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å
addresses = monitor.get_subscribed_addresses()  # –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞–¥—Ä–µ—Å–æ–≤
FundsCollector
–°–µ—Ä–≤–∏—Å –¥–ª—è —Å–±–æ—Ä–∞ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –º–∞—Å—Ç–µ—Ä-–∞–¥—Ä–µ—Å.

python
from node_manager.services.collector import FundsCollector

collector = FundsCollector(
    node=node,                               # –≠–∫–∑–µ–º–ø–ª—è—Ä –Ω–æ–¥—ã
    master_address="–º–∞—Å—Ç–µ—Ä_–∞–¥—Ä–µ—Å",          # –ê–¥—Ä–µ—Å –¥–ª—è —Å–±–æ—Ä–∞
    fee=0.0001                               # –ö–æ–º–∏—Å—Å–∏—è —Å–±–æ—Ä–∞
)

# –°–±–æ—Ä —Å –æ–¥–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞
result = await collector.collect_from_address(
    address="–∏—Å—Ö–æ–¥–Ω—ã–π_–∞–¥—Ä–µ—Å",
    private_key="–ø—Ä–∏–≤–∞—Ç–Ω—ã–π_–∫–ª—é—á"            # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
)

# –ü–∞–∫–µ—Ç–Ω—ã–π —Å–±–æ—Ä
results = await collector.collect_multiple(
    addresses=["–∞–¥—Ä–µ—Å1", "–∞–¥—Ä–µ—Å2"],
    private_keys={"–∞–¥—Ä–µ—Å1": "–∫–ª—é—á1"}        # –°–ª–æ–≤–∞—Ä—å –∫–ª—é—á–µ–π
)

# –û—Ü–µ–Ω–∫–∞ —Å–±–æ—Ä–∞
estimation = await collector.estimate_collection("–∞–¥—Ä–µ—Å")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
collector.set_fee(0.0002)                   # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–º–∏—Å—Å–∏—é
collector.set_min_amount(0.002)             # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É
NodeConfig
–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π.

python
from node_manager.nodeconfig import NodeConfig

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = NodeConfig.load_config("node_config.yaml")

# –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
NodeConfig.update_api_key("–Ω–æ–≤—ã–π_–∫–ª—é—á")                     # –û–±–Ω–æ–≤–∏—Ç—å API –∫–ª—é—á
NodeConfig.enable_coin("BTC", True)                        # –í–∫–ª—é—á–∏—Ç—å –º–æ–Ω–µ—Ç—É
NodeConfig.set_master_address("LTC", "–Ω–æ–≤—ã–π_–∞–¥—Ä–µ—Å")        # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∞—Å—Ç–µ—Ä-–∞–¥—Ä–µ—Å
NodeConfig.set_collection_params("LTC", min_amount=0.002)  # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–±–æ—Ä–∞

# –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
enabled_coins = NodeConfig.get_enabled_coins()             # –í–∫–ª—é—á–µ–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç—ã
ltc_config = NodeConfig.get_coin_config("LTC")             # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–Ω–µ—Ç—ã
NodeConfig.generate_config_template()                       # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —à–∞–±–ª–æ–Ω–∞
‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç
–®–∞–≥ 1: –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Å–∞ –º–æ–Ω–µ—Ç—ã
python
# node_manager/core/ethereum.py
"""
–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–¥—ã Ethereum
"""

import logging
from typing import Dict, List, Any, Union
from decimal import Decimal
from .base_node import BaseNode

logger = logging.getLogger(__name__)

class EthereumNode(BaseNode):
    """–ù–æ–¥–∞ Ethereum"""
    
    def __init__(self, **kwargs):
        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        kwargs.setdefault('coin_type', 'ETH')
        kwargs.setdefault('coin_name', 'Ethereum')
        kwargs.setdefault('decimals', 18)  # Ethereum –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 18 –∑–Ω–∞–∫–æ–≤
        
        # URL –¥–ª—è Ethereum (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è Nownodes)
        if not kwargs.get('blockbook_url'):
            kwargs['blockbook_url'] = 'https://ethbook.nownodes.io'
        if not kwargs.get('rpc_url'):
            kwargs['rpc_url'] = 'https://eth.nownodes.io'
        
        super().__init__(**kwargs)
    
    async def connect(self) -> bool:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Ethereum –Ω–æ–¥–µ"""
        try:
            # Ethereum –∏—Å–ø–æ–ª—å–∑—É–µ—Ç JSON-RPC API
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ web3_clientVersion
            if self.rpc_client:
                result = await self.rpc_client.call("web3_clientVersion", [])
                if 'error' not in result:
                    self._connected = True
                    logger.info(f"Connected to Ethereum node")
                    return True
            
            self._connected = True
            logger.info(f"Connected to Ethereum node")
            return True
            
        except Exception as e:
            logger.error(f"Error connecting to Ethereum: {e}")
            self._connected = False
            return False
    
    async def get_balance(self, address: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å –∞–¥—Ä–µ—Å–∞ –≤ ETH"""
        try:
            if not self.rpc_client:
                return {'error': 'RPC client not available'}
            
            # Ethereum –∏—Å–ø–æ–ª—å–∑—É–µ—Ç eth_getBalance
            result = await self.rpc_client.call("eth_getBalance", [address, "latest"])
            
            if 'error' in result:
                return result
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–∑ wei –≤ ETH
            balance_wei = int(result.get('result', '0x0'), 16)
            balance_eth = balance_wei / (10 ** self.decimals)
            
            return {
                'address': address,
                'balance': balance_eth,
                'in_wei': balance_wei,
                'coin': 'ETH'
            }
            
        except Exception as e:
            logger.error(f"Error getting ETH balance: {e}")
            return {'error': str(e)}
    
    # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤...
    # get_transaction, send_transaction –∏ —Ç.–¥.

    async def send_transaction(self, raw_tx_hex: str) -> str:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é Ethereum"""
        try:
            if not self.rpc_client:
                raise Exception("RPC client not available")
            
            # Ethereum –∏—Å–ø–æ–ª—å–∑—É–µ—Ç eth_sendRawTransaction
            result = await self.rpc_client.call("eth_sendRawTransaction", [raw_tx_hex])
            
            if 'error' in result:
                raise Exception(f"RPC error: {result['error']}")
            
            tx_hash = result.get('result')
            logger.info(f"ETH transaction sent: {tx_hash}")
            return tx_hash
            
        except Exception as e:
            logger.error(f"Error sending ETH transaction: {e}")
            raise

    async def estimate_fee(self, blocks: int = 3) -> Dict[str, Any]:
        """–û—Ü–µ–Ω–∏—Ç—å –∫–æ–º–∏—Å—Å–∏—é Gas –¥–ª—è Ethereum"""
        try:
            if not self.rpc_client:
                return {'error': 'RPC client not available'}
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π base fee –∏ priority fee
            fee_history = await self.rpc_client.call("eth_feeHistory", [blocks, "latest", [25, 50, 75]])
            
            if 'error' in fee_history:
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                return {
                    'base_fee': 30,  # Gwei
                    'max_priority_fee': 2,  # Gwei
                    'max_fee': 32,  # Gwei
                    'gas_limit': 21000,
                    'coin': 'ETH'
                }
            
            # –ü–∞—Ä—Å–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            # ... –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ feeHistory ...
            
            return {
                'base_fee': 30,
                'max_priority_fee': 2,
                'max_fee': 32,
                'gas_limit': 21000,
                'coin': 'ETH'
            }
            
        except Exception as e:
            logger.error(f"Error estimating ETH fee: {e}")
            return {'error': str(e)}
–®–∞–≥ 2: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–Ω–µ—Ç—ã –≤ —Ñ–∞–±—Ä–∏–∫–µ
python
# –í node_manager/core/node_factory.py –¥–æ–±–∞–≤–∏—Ç—å:

from .ethereum import EthereumNode

class NodeFactory:
    _node_classes = {
        'LTC': LitecoinNode,
        'DOGE': DogecoinNode,
        'BTC': BitcoinNode,
        'ETH': EthereumNode,  # –î–æ–±–∞–≤–ª–µ–Ω–æ
    }
    
    _default_configs = {
        # ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏ ...
        'ETH': {
            'blockbook_url': 'https://ethbook.nownodes.io',
            'rpc_url': 'https://eth.nownodes.io',
            'network': 'mainnet',
            'decimals': 18,
            'coin_symbol': 'ETH',
            'coin_name': 'Ethereum',
            'min_collection_amount': 0.01,
            'collection_fee': 0.001,
            'required_confirmations': 12
        }
    }
–®–∞–≥ 3: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
yaml
# –í node_config.yaml –¥–æ–±–∞–≤–∏—Ç—å:
coins:
  ETH:
    enabled: true
    blockbook_url: "https://ethbook.nownodes.io"
    rpc_url: "https://eth.nownodes.io"
    network: "mainnet"
    decimals: 18
    coin_symbol: "ETH"
    coin_name: "Ethereum"
    master_address: "0x–≤–∞—à_–º–∞—Å—Ç–µ—Ä_–∞–¥—Ä–µ—Å"
    min_collection_amount: 0.01
    collection_fee: 0.001
    required_confirmations: 12
–®–∞–≥ 4: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –º–æ–Ω–µ—Ç—ã
python
# –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Ethereum
from node_manager import NodeManager

async def use_ethereum():
    manager = NodeManager()
    eth_node = await manager.get_node("ETH")
    
    balance = await eth_node.get_balance("0x–∞–¥—Ä–µ—Å")
    print(f"–ë–∞–ª–∞–Ω—Å ETH: {balance['balance']}")
üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥:
python
from node_manager import NodeManager

async def monitoring_example():
    manager = NodeManager()
    
    # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–º
    async def handle_event(coin, data):
        event_type = data.get('type')
        
        if event_type == 'transaction':
            print(f"–ù–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è {coin}: {data['transaction']['txid']}")
        elif event_type == 'block':
            print(f"–ù–æ–≤—ã–π –±–ª–æ–∫ {coin}: #{data['block']['height']}")
    
    await manager.start_monitoring_for_all(handle_event)
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    await manager.monitor_address("LTC", "ltc1q...")
    await manager.monitor_address("DOGE", "D...")
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    stats = await manager.get_monitoring_stats()
    print(f"–ê–¥—Ä–µ—Å–æ–≤ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ: {stats['addresses_monitored']}")
–í–Ω–µ—à–Ω–∏–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus/Grafana):
python
# –ü—Ä–∏–º–µ—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞ –º–µ—Ç—Ä–∏–∫ –≤ Prometheus
from prometheus_client import start_http_server, Gauge, Counter
import asyncio
from node_manager import NodeManager

# –ú–µ—Ç—Ä–∏–∫–∏ Prometheus
NODE_BLOCK_HEIGHT = Gauge('node_block_height', 'Block height by coin', ['coin'])
NODE_CONNECTIONS = Gauge('node_connections', 'Node connections status', ['coin'])
TRANSACTIONS_PROCESSED = Counter('transactions_processed', 'Transactions processed', ['coin'])

async def export_metrics():
    """–≠–∫—Å–ø–æ—Ä—Ç –º–µ—Ç—Ä–∏–∫ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    manager = NodeManager()
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è Prometheus
    start_http_server(8000)
    
    while True:
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–∂–¥–æ–π –Ω–æ–¥–µ
            config = manager.config
            for coin in config.get('coins', {}).keys():
                try:
                    node = await manager.get_node(coin)
                    info = await node.get_blockchain_info()
                    
                    if 'error' not in info:
                        # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–µ—Ç—Ä–∏–∫–∏
                        NODE_BLOCK_HEIGHT.labels(coin=coin).set(info.get('blocks', 0))
                        NODE_CONNECTIONS.labels(coin=coin).set(1)
                    else:
                        NODE_CONNECTIONS.labels(coin=coin).set(0)
                        
                except Exception as e:
                    NODE_CONNECTIONS.labels(coin=coin).set(0)
            
            # –ñ–¥–µ–º 30 —Å–µ–∫—É–Ω–¥
            await asyncio.sleep(30)
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –º–µ—Ç—Ä–∏–∫: {e}")
            await asyncio.sleep(60)

# –ó–∞–ø—É—Å–∫ —ç–∫—Å–ø–æ—Ä—Ç–∞ –º–µ—Ç—Ä–∏–∫
asyncio.run(export_metrics())
–ì—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –¥–∞—à–±–æ—Ä–¥:
html
<!-- –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å—Ç–æ–≥–æ –¥–∞—à–±–æ—Ä–¥–∞ -->
<!DOCTYPE html>
<html>
<head>
    <title>Node Manager Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Node Manager Dashboard</h1>
    
    <div class="stats">
        <div class="stat">
            <h3>Block Height</h3>
            <canvas id="blockChart"></canvas>
        </div>
        
        <div class="stat">
            <h3>Addresses Monitored</h3>
            <canvas id="addressChart"></canvas>
        </div>
        
        <div class="stat">
            <h3>Collections</h3>
            <canvas id="collectionChart"></canvas>
        </div>
    </div>
    
    <script>
        // –ó–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö —Å API
        async function fetchStats() {
            const response = await fetch('/api/stats');
            return await response.json();
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤
        async function updateCharts() {
            const stats = await fetchStats();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –±–ª–æ–∫–∏
            updateBlockChart(stats.block_heights);
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–¥—Ä–µ—Å–∞
            updateAddressChart(stats.addresses);
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–±–æ—Ä—ã
            updateCollectionChart(stats.collections);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        setInterval(updateCharts, 30000);
        updateCharts(); // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
    </script>
</body>
</html>
üõ†Ô∏è –û—Ç–ª–∞–¥–∫–∞
–í–∫–ª—é—á–µ–Ω–∏–µ –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è:
python
import logging

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

# –ò–ª–∏ —á–µ—Ä–µ–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
import yaml
config = {
    'services': {
        'logging': {
            'level': 'DEBUG',
            'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            'file': 'node_debug.log'
        }
    }
}

with open('node_config_debug.yaml', 'w') as f:
    yaml.dump(config, f)
–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:
python
# test_connection.py
import asyncio
import logging
from node_manager import NodeManager

logging.basicConfig(level=logging.DEBUG)

async def test_connections():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫–æ –≤—Å–µ–º –Ω–æ–¥–∞–º"""
    manager = NodeManager()
    
    print("üîç –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π...")
    
    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –º–æ–Ω–µ—Ç—É
    coins_to_test = ["LTC", "DOGE", "BTC"]
    
    for coin in coins_to_test:
        try:
            print(f"\nüì° –¢–µ—Å—Ç–∏—Ä—É–µ–º {coin}...")
            
            # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–¥—É
            node = await manager.get_node(coin)
            
            # –¢–µ—Å—Ç 1: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
            print(f"   –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ... ", end="")
            connected = await node.connect()
            print("‚úÖ" if connected else "‚ùå")
            
            if connected:
                # –¢–µ—Å—Ç 2: –ë–ª–æ–∫—á–µ–π–Ω –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                print(f"   –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–ª–æ–∫—á–µ–π–Ω–µ... ", end="")
                info = await node.get_blockchain_info()
                if 'error' not in info:
                    print(f"‚úÖ (–ë–ª–æ–∫: {info.get('blocks', 0)})")
                else:
                    print(f"‚ùå ({info.get('error', 'Unknown error')})")
                
                # –¢–µ—Å—Ç 3: –û—Ü–µ–Ω–∫–∞ –∫–æ–º–∏—Å—Å–∏–∏
                print(f"   –û—Ü–µ–Ω–∫–∞ –∫–æ–º–∏—Å—Å–∏–∏... ", end="")
                fee = await node.estimate_fee()
                if 'error' not in fee:
                    print(f"‚úÖ ({fee.get('fee_per_kb')} –∑–∞ KB)")
                else:
                    print(f"‚ùå")
                
                # –¢–µ—Å—Ç 4: –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞–¥—Ä–µ—Å–∞
                test_address = {
                    "LTC": "ltc1q489hgnahvr9zspytmsu6vew8nc4j6c3aqkdvxg",
                    "DOGE": "D7i9UYtC6r5jz4g3h2f1d0s9a8w7q6e5r4t3y2u1i",
                    "BTC": "bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq"
                }.get(coin, "")
                
                if test_address:
                    print(f"   –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞... ", end="")
                    validation = await node.validate_address(test_address)
                    print("‚úÖ" if validation.get('is_valid') else "‚ùå")
            
            # –û—Ç–∫–ª—é—á–∞–µ–º—Å—è
            await node.disconnect()
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ {coin}: {e}")
    
    print("\nüéØ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ")

asyncio.run(test_connections())
–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:
python
# performance_monitor.py
import asyncio
import time
import statistics
from node_manager import NodeManager

class PerformanceMonitor:
    def __init__(self):
        self.latencies = {}
        self.manager = NodeManager()
    
    async def measure_method(self, coin, method_name, *args):
        """–ò–∑–º–µ—Ä–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–∞"""
        try:
            node = await self.manager.get_node(coin)
            method = getattr(node, method_name)
            
            start_time = time.time()
            result = await method(*args)
            elapsed = time.time() - start_time
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            key = f"{coin}.{method_name}"
            if key not in self.latencies:
                self.latencies[key] = []
            
            self.latencies[key].append(elapsed)
            
            return {
                'success': 'error' not in result,
                'time': elapsed,
                'result': result
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'time': 0
            }
    
    async def run_performance_test(self, iterations=10):
        """–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        print("üöÄ –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏...")
        
        methods_to_test = [
            ("get_balance", ["ltc1q..."]),
            ("get_blockchain_info", []),
            ("estimate_fee", [3]),
            ("validate_address", ["ltc1q..."])
        ]
        
        for coin in ["LTC", "DOGE"]:
            print(f"\nüîß –¢–µ—Å—Ç–∏—Ä—É–µ–º {coin}:")
            
            for method_name, args in methods_to_test:
                times = []
                successes = 0
                
                for i in range(iterations):
                    result = await self.measure_method(coin, method_name, *args)
                    
                    if result['success']:
                        times.append(result['time'])
                        successes += 1
                    
                    # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                    await asyncio.sleep(0.5)
                
                if times:
                    avg_time = statistics.mean(times)
                    min_time = min(times)
                    max_time = max(times)
                    
                    print(f"   {method_name}:")
                    print(f"     –£—Å–ø–µ—à–Ω–æ: {successes}/{iterations}")
                    print(f"     –°—Ä–µ–¥–Ω–µ–µ: {avg_time:.3f} —Å–µ–∫")
                    print(f"     –ú–∏–Ω–∏–º—É–º: {min_time:.3f} —Å–µ–∫")
                    print(f"     –ú–∞–∫—Å–∏–º—É–º: {max_time:.3f} —Å–µ–∫")
                else:
                    print(f"   {method_name}: ‚ùå –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–µ—É–¥–∞—á–Ω—ã")
        
        print("\nüéØ –¢–µ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∑–∞–≤–µ—Ä—à–µ–Ω")

async def main():
    monitor = PerformanceMonitor()
    await monitor.run_performance_test(iterations=5)

if __name__ == "__main__":
    asyncio.run(main())
üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤:
python
# optimized_manager.py
import asyncio
from node_manager import NodeManager
from node_manager.utils.exceptions import NodeError

class OptimizedNodeManager(NodeManager):
    """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._cache = {}
        self._cache_ttl = 300  # 5 –º–∏–Ω—É—Ç
        
    async def get_balance_cached(self, coin, address, force_refresh=False):
        """–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤"""
        cache_key = f"{coin}:{address}:balance"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if not force_refresh and cache_key in self._cache:
            cache_data = self._cache[cache_key]
            if time.time() - cache_data['timestamp'] < self._cache_ttl:
                return cache_data['data']
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ
        node = await self.get_node(coin)
        balance = await node.get_balance(address)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
        self._cache[cache_key] = {
            'data': balance,
            'timestamp': time.time()
        }
        
        # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞
        self._clean_old_cache()
        
        return balance
    
    async def batch_monitor_addresses(self, coin, addresses):
        """–ü–∞–∫–µ—Ç–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–æ–≤ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"""
        node = await self.get_node(coin)
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –∞–¥—Ä–µ—Å–æ–≤ –∑–∞ –æ–¥–∏–Ω —Ä–∞–∑
        validation_tasks = []
        for address in addresses:
            validation_tasks.append(node.validate_address(address))
        
        validation_results = await asyncio.gather(*validation_tasks)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–µ –∞–¥—Ä–µ—Å–∞
        valid_addresses = []
        for address, validation in zip(addresses, validation_results):
            if validation.get('is_valid'):
                valid_addresses.append(address)
        
        # –ü–∞–∫–µ—Ç–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ (–µ—Å–ª–∏ API –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç)
        if valid_addresses:
            # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–∫–µ—Ç–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏
            # –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π Nownodes API
            pass
        
        return {
            'total': len(addresses),
            'valid': len(valid_addresses),
            'invalid': len(addresses) - len(valid_addresses),
            'valid_addresses': valid_addresses
        }
    
    def _clean_old_cache(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞"""
        current_time = time.time()
        keys_to_delete = []
        
        for key, data in self._cache.items():
            if current_time - data['timestamp'] > self._cache_ttl * 2:
                keys_to_delete.append(key)
        
        for key in keys_to_delete:
            del self._cache[key]
    
    async def health_check_all(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –≤—Å–µ—Ö –Ω–æ–¥ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ"""
        tasks = []
        
        for coin in self._get_enabled_coins():
            tasks.append(self._check_node_health(coin))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        health_status = {}
        for coin, result in zip(self._get_enabled_coins(), results):
            if isinstance(result, Exception):
                health_status[coin] = {
                    'healthy': False,
                    'error': str(result)
                }
            else:
                health_status[coin] = {
                    'healthy': True,
                    'block_height': result.get('blocks', 0)
                }
        
        return health_status
    
    async def _check_node_health(self, coin):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –Ω–æ–¥—ã"""
        try:
            node = await self.get_node(coin)
            info = await node.get_blockchain_info()
            return info
        except Exception as e:
            raise Exception(f"Node {coin} health check failed: {e}")

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
async def main():
    manager = OptimizedNodeManager()
    
    # –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–¥—Ä–µ—Å–æ–≤
    addresses = ["ltc1q..."] * 100  # 100 –∞–¥—Ä–µ—Å–æ–≤
    result = await manager.batch_monitor_addresses("LTC", addresses)
    print(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {result['total']} –∞–¥—Ä–µ—Å–æ–≤, {result['valid']} –≤–∞–ª–∏–¥–Ω—ã—Ö")
    
    # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    balance = await manager.get_balance_cached("LTC", "ltc1q...")
    print(f"–ë–∞–ª–∞–Ω—Å: {balance['total']}")
    
    # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
    health = await manager.health_check_all()
    for coin, status in health.items():
        print(f"{coin}: {'‚úÖ' if status['healthy'] else '‚ùå'}")

asyncio.run(main())
ü§ù –í–∫–ª–∞–¥ –≤ –ø—Ä–æ–µ–∫—Ç
–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏:
bash
# –ö–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
git clone https://github.com/yourusername/node-manager.git
cd node-manager

# –°–æ–∑–¥–∞–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
python -m venv venv
source venv/bin/activate  # Linux/Mac
# –∏–ª–∏
venv\Scripts\activate  # Windows

# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
pip install -r requirements.txt
pip install -r requirements-dev.txt

# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –º–æ–¥—É–ª—å –≤ —Ä–µ–∂–∏–º–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
pip install -e .
–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤:
bash
# –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤
pytest tests/

# –ó–∞–ø—É—Å–∫ —Å –ø–æ–∫—Ä—ã—Ç–∏–µ–º –∫–æ–¥–∞
pytest tests/ --cov=node_manager --cov-report=html

# –ó–∞–ø—É—Å–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
pytest tests/test_litecoin_node.py -v

# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ä–∞–∑–Ω—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ Python
tox
–°—Ç–∏–ª—å –∫–æ–¥–∞:
bash
# –ê–≤—Ç–æ—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
black node_manager/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∏–ª—è
flake8 node_manager/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy node_manager/

# –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏–º–ø–æ—Ä—Ç–æ–≤
isort node_manager/
–ü—Ä–æ—Ü–µ—Å—Å –≤–Ω–µ—Å–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π:
–§–æ—Ä–∫–Ω–∏—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π

–°–æ–∑–¥–∞–π—Ç–µ –≤–µ—Ç–∫—É –¥–ª—è –≤–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ (git checkout -b feature/amazing-feature)

–ó–∞–∫–æ–º–º–∏—Ç—å—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (git commit -m 'Add amazing feature')

–ó–∞–ø—É—à—å—Ç–µ –≤ –≤–µ—Ç–∫—É (git push origin feature/amazing-feature)

–û—Ç–∫—Ä–æ–π—Ç–µ Pull Request

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–µ—Å—Ç–æ–≤:
text
tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py              # –§–∏–∫—Å—Ç—É—Ä—ã
‚îú‚îÄ‚îÄ test_base_node.py       # –¢–µ—Å—Ç—ã –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞
‚îú‚îÄ‚îÄ test_litecoin_node.py   # –¢–µ—Å—Ç—ã Litecoin
‚îú‚îÄ‚îÄ test_dogecoin_node.py   # –¢–µ—Å—Ç—ã Dogecoin
‚îú‚îÄ‚îÄ test_node_factory.py    # –¢–µ—Å—Ç—ã —Ñ–∞–±—Ä–∏–∫–∏
‚îú‚îÄ‚îÄ test_monitor.py         # –¢–µ—Å—Ç—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
‚îú‚îÄ‚îÄ test_collector.py       # –¢–µ—Å—Ç—ã —Å–±–æ—Ä—â–∏–∫–∞
‚îú‚îÄ‚îÄ test_manager.py         # –¢–µ—Å—Ç—ã –º–µ–Ω–µ–¥–∂–µ—Ä–∞
‚îî‚îÄ‚îÄ integration/            # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
    ‚îú‚îÄ‚îÄ test_connection.py
    ‚îî‚îÄ‚îÄ test_transactions.py
–ü—Ä–∏–º–µ—Ä —Ç–µ—Å—Ç–∞:
python
# tests/test_litecoin_node.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock
from node_manager.core.litecoin import LitecoinNode

class TestLitecoinNode:
    @pytest.fixture
    def node(self):
        """–§–∏–∫—Å—Ç—É—Ä–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–π –Ω–æ–¥—ã"""
        return LitecoinNode(
            coin_type="LTC",
            api_key="test_key",
            blockbook_url="https://test.com",
            rpc_url="https://test.com"
        )
    
    @pytest.mark.asyncio
    async def test_connect_success(self, node):
        """–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è"""
        # –ú–æ–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç–æ–≤
        node.rpc_client = AsyncMock()
        node.rpc_client.call.return_value = {'result': {'blocks': 1000}}
        
        node.blockbook_client = AsyncMock()
        node.blockbook_client.get_blockbook_info.return_value = {}
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        result = await node.connect()
        
        assert result is True
        assert node.is_connected() is True
    
    @pytest.mark.asyncio
    async def test_get_balance(self, node):
        """–¢–µ—Å—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞"""
        # –ú–æ–∫–∞–µ–º blockbook_client
        node.blockbook_client = AsyncMock()
        node.blockbook_client.get_address_info.return_value = {
            'balance': 100000000,  # 1 LTC –≤ —Å–∞—Ç–æ—à–∏
            'unconfirmedBalance': 50000000,  # 0.5 LTC
            'totalReceived': 150000000,
            'txs': 5
        }
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞
        balance = await node.get_balance("ltc1qtest")
        
        assert balance['address'] == "ltc1qtest"
        assert balance['confirmed'] == 1.0  # 1 LTC
        assert balance['unconfirmed'] == 0.5  # 0.5 LTC
        assert balance['total'] == 1.5
        assert balance['transaction_count'] == 5
    
    @pytest.mark.asyncio
    async def test_validate_address(self, node):
        """–¢–µ—Å—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∞–¥—Ä–µ—Å–∞"""
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –≤–∞–ª–∏–¥–Ω—ã–π –∞–¥—Ä–µ—Å
        node.blockbook_client = AsyncMock()
        node.blockbook_client.get_address_info.return_value = {}
        
        validation = await node.validate_address("ltc1qtestaddress")
        
        assert validation['is_valid'] is True
        assert validation['address'] == "ltc1qtestaddress"
üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è
–≠—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç—Å—è –ø–æ–¥ –ª–∏—Ü–µ–Ω–∑–∏–µ–π MIT. –°–º. —Ñ–∞–π–ª LICENSE –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.

–û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª–æ–∂–µ–Ω–∏—è:
–†–∞–∑—Ä–µ—à–µ–Ω–æ:

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö —Ü–µ–ª—è—Ö

–ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —á–∞—Å—Ç–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö

–†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –∞–≤—Ç–æ—Ä—Å—Ç–≤–∞

–¢—Ä–µ–±—É–µ—Ç—Å—è:

–°–æ—Ö—Ä–∞–Ω—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –∞–≤—Ç–æ—Ä—Å–∫–∏—Ö –ø—Ä–∞–≤–∞—Ö –∏ –ª–∏—Ü–µ–Ω–∑–∏–∏

–£–∫–∞–∑—ã–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥–µ

–ó–∞–ø—Ä–µ—â–µ–Ω–æ:

–û—Ç–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –æ—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –∞–≤—Ç–æ—Ä–∞

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä–Ω—ã–µ –∑–Ω–∞–∫–∏ –∞–≤—Ç–æ—Ä–∞

–ê–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞:
text
Copyright (c) 2024 Node Manager Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
–í–∫–ª–∞–¥—á–∏–∫–∏:
–û—Å–Ω–æ–≤–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫: –í–∞—à–µ –ò–º—è

–ö–æ–Ω—Ç—Ä–∏–±—å—é—Ç–æ—Ä—ã: –°–ø–∏—Å–æ–∫ –≤–∫–ª–∞–¥—á–∏–∫–æ–≤

–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞:
–ï—Å–ª–∏ –≤—ã –Ω–∞—à–ª–∏ —ç—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç –ø–æ–ª–µ–∑–Ω—ã–º, —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å:

‚≠ê –ü–æ—Å—Ç–∞–≤–∏—Ç—å –∑–≤–µ–∑–¥—É –Ω–∞ GitHub

üêõ –°–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ —á–µ—Ä–µ–∑ Issues

üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å —É–ª—É—á—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Pull Requests

‚òï –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–æ—Ñ–µ

<div align="center">
–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Node Manager! üöÄ

–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å, —Å–æ–∑–¥–∞–π—Ç–µ Issue –Ω–∞ GitHub.

–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è |
–ü—Ä–∏–º–µ—Ä—ã |
Issues

</div>
–¢–µ–ø–µ—Ä—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—é –ø–æ–ª–Ω—ã–π –∫–æ–¥ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –º–æ–¥—É–ª—è.
